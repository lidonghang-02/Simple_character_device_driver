# 简单字符型设备驱动
> 代码整体非常简单，目前仍有许多bug，是作者学习linux驱动编写的第一个尝试，bug未来大概率不会修改
## 整体思路：
1. 编写字符型设备驱动程序，实现加解密功能。首先需要定义一个字符型设备驱动程序，注册设备，实现设备文件的打开、关闭、读写和 ioctl 操作函数。在 ioctl 函数中，实现 Setkey、SetMode、StartWrite、StartRead 和 Reset 命令的处理函数，以及加解密算法的实现函数。
2. 设计测试程序，测试加解密功能是否正确。测试程序可以使用 C语言编写，主要包括小数据加密和大数据加密测试。

## 具体代码架构：
1. 设备驱动程序部分
- 定义设备结构体，包括设备的缓冲区、缓冲区大小、读写指针等信息。
- 实现设备文件的打开、关闭、读写和 ioctl 操作函数，其中 ioctl 操作函数主要处理 Setkey、SetMode、StartWrite、StartRead 和 Reset 命令。
- 在write和read函数中实现加密解密算法

2. 测试程序部分
- 实现小数据加密和解密的测试函数，测试加密前后数据是否一致。
- 实现大数据加密和解密的测试函数，测试多次使用 Write 命令写入数据后，加密前后数据是否一致。

3. ioctl 中的各项功能：
- Setkey：设置加密算法的密钥，后面的write会写入密钥。
- SetMode：设置加解密模式，通过 ioctl 命令传递一个表示加密还是解密的标志，将标志保存在设备结构体中。
	- mode有3种模式，加密模式（ENCRYPTION）,解密模式（DECRYPTION），常规模式（NORMAL）
- StartWrite：设置开始写入状态，表示后续的数据写入操作是加密数据，并将写指针指向缓冲区的起始位置。
- StartRead：设置开始读出状态，表示后续的数据读出操作是解密数据，并将读指针指向缓冲区的起始位置。
- Reset：清空设备缓冲区，将读写指针重置为缓冲区的起始位置。

## 缺陷
- 写入的数据只能读取一次
- 当数据达到1MB时
	- 读取速度非常慢，且容易出错
	- 读取需要采用for循环嵌套的方式读取，只是用read函数读取1024*1024会出错

## 安装驱动程序

编译

```
make
```

安装驱动

```
chmod 777 encryption.ko
sudo insmod encryption.ko
```
- 注意：如果安装不成功，提示Device or resource busy，可以使用如下命令查看已占用的设备号，并将源文件中的`major`修改为空闲设备号，重新编译插入即可：
```
cat /proc/devices
```



## 测试

### 编译运行测试文件`test.c`

```
gcc test,c -o test
sudo ./test
```

### 测试内容

测试内容分为小数据和大数据测试两部分

1. 首先设置密钥为`asdasd`

2. 小数据测试
	- 设置加密模式并写入数据`qwer`
	- 在正常模式下读取数据
	- 再次设置加密模式并写入数据`qwer`
	- 在解密模式下读取数据
3. 大数据测试
	- 在加密模式下，使用循环不断写入`abc`直到1MB
	- 在解密模式下，使用循环嵌套读取内容写入`out.txt`文件
		- 程序结束后查看`out.txt`文件的大小可以看到为1MB